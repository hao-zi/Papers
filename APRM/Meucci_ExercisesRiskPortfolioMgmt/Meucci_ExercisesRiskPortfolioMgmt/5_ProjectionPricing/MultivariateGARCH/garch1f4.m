function [q,qerr,hf,hferr]=garch1f4(x,eps,df)

% function [q,qerr,hf,hferr]=garch1f3(x)
%
% x: column vector of data generated by a GARCH(1,1) process
% q: parameters of the GARCH(1,1) process
% qerr: standard error of parameter estimates
% hf: current conditional heteroskedasticity estimate
% hferr: standard error on hf
%
% Uses a conditional t-distribution with fixed degrees of freedom
%
% Written by Olivier Ledoit, 4/28/1997

% Difference with garch1f: errors come from the score alone

% Parameters
gold=(1+sqrt(5))/2;	% step size increment 
tol1=1e-7; 		% for termination criterion
tol2=1e-7;		% for closeness to boundary
big=2;			% for making the hessian negative definite
maxiter=50;		% maximum number of iterations
n=30;		    	% number of points on the grid

% Rescale
y=(x(:)-mean(x(:))).^2;
t=length(y);
scale=sqrt(mean(y.^2));
y=y./scale;
s=mean(y);

% Grid search
[ag,bg]=meshgrid(linspace(0,1-eps,n),linspace(0,1-eps,n));
cg=max(s.*(1-ag-bg),0);
likeg=-Inf*ones(n);
for i=1:n
	%h0=filter([0 1],[1 -bg(i,1)],ones(t,1));
	for j=1:n-i+1
      h=filter([0 ag(i,j)],[1 -bg(i,j)],y*(df-2)/df,s*(df-2)/df)+ ...
          +filter([0 cg(i,j)],[1 -bg(i,j)],ones(t,1));
      likeg(i,j)=-sum(log(h)+(df+1)*log(1+y./h./df));
	end
end
maxlikeg=max(max(likeg));
maxima=find(likeg==maxlikeg);
maximum=max(maxima);

% Initialize optimization
a=[cg(maximum) ag(maximum) bg(maximum)];
best=0;
da=0;
term=1;
negdef=0;
iter=0;

% Begin optimization loop
while iter<maxiter;
iter=iter+1;

% New parameter1
a=a+gold^best*da;

% Conditional variance
h=filter([0 a(2)],[1 -a(3)],y*(df-2)/df,s*(df-2)/df)...
  +filter([0 a(1)],[1 -a(3)],ones(t,1));

% Likelihood
if (any(a<0)|(a(2)+a(3)>1-eps))
	like=-Inf;
else
  %like=-sum(log(h)+y./h));
   like=-sum(log(h)+(df+1)*log(1+y./h./df));
end

% Gradient
GG=[ filter([0 1],[1 -a(3)],ones(t,1)) ...
     filter([0 1],[1 -a(3)],y*(df-2)/df)	       ...
     filter([0 1],[1 -a(3)],h)	       ];
%g1=y./h.^2-1./h;
 g1=((df+1)*(y./(y+df*h))-1)./h;
G=GG.*g1(:,ones(1,3));
gra=sum(G);

% Hessian
GG2=GG(:,[1 2 3 1 2 3 1 2 3]).*GG(:,[1 1 1 2 2 2 3 3 3]); 
%g2=-2*y./h.^3+1./h.^2;
 g2=-((df+1)*(y./(y+df*h))-1)./h.^2-(df*(df+1))*(y./(y+df*h).^2./h);
HH=zeros(t,9);
HH(:,3)=filter([0 1],[1 -a(3)],GG(:,1));
HH(:,7)=HH(:,3);
HH(:,6)=filter([0 1],[1 -a(3)],GG(:,2));
HH(:,8)=HH(:,6);
HH(:,9)=filter([0 2],[1 -a(3)],GG(:,3));
H=GG2.*g2(:,ones(1,9))+HH.*g1(:,ones(1,9));
hes=reshape(sum(H),3,3);

% Negative definite
[u,d]=eig(hes);
d=diag(d);
if any(d>0)
	negdef=0;
	d=min(d,max(d(d<0))/big);
	hes=u*diag(d)*u';
else
	negdef=1;
end

% Direction
da=-gra/hes;

% Termination criterion
term=da*gra';
if ((term<tol1)&negdef)
	break
end

% Step search	
best=0;
newa=a+gold^(best-1)*da;
if (any(newa<0)|(newa(2)+newa(3)>1-eps))
	left=-Inf;
else
	h=filter([0 newa(2)],[1 -newa(3)],y*(df-2)/df,s*(df-2)/df)...
  	  +filter([0 newa(1)],[1 -newa(3)],ones(t,1));
  %left=-sum(log(h)+y./h);
   left=-sum(log(h)+(df+1)*log(1+y./h./df));
end
newa=a+gold^best*da;
if (any(newa<0)|(newa(2)+newa(3)>1-eps))
	center=-Inf;
else
	h=filter([0 newa(2)],[1 -newa(3)],y*(df-2)/df,s*(df-2)/df)...
	  +filter([0 newa(1)],[1 -newa(3)],ones(t,1));
  %center=-sum(log(h)+y./h);
   center=-sum(log(h)+(df+1)*log(1+y./h./df));
end
newa=a+gold^(best+1)*da;
if (any(newa<0)|(newa(2)+newa(3)>1-eps))
	right=-Inf;
else
	h=filter([0 newa(2)],[1 -newa(3)],y*(df-2)/df,s*(df-2)/df)...
   	  +filter([0 newa(1)],[1 -newa(3)],ones(t,1));
  %right=-sum(log(h)+y./h);
   right=-sum(log(h)+(df+1)*log(1+y./h./df));
end
if all(like>[left center right])|all(left>[center right])
	while 1
		best=best-1;
		center=left;
		newa=a+gold^(best-1)*da;
		if (any(newa<0)|(newa(2)+newa(3)>1-eps))
			left=-Inf;
		else
			h=filter([0 newa(2)],[1 -newa(3)],y*(df-2)/df,s*(df-2)/df)...
		  	  +filter([0 newa(1)],[1 -newa(3)],ones(t,1));
        %left=-sum(log(h)+y./h);
         left=-sum(log(h)+(df+1)*log(1+y./h./df));
		end
		if all(center>=[like left])
			break
		end
	end
elseif all(right>[left center])
	while 1
		best=best+1;
		center=right;
		newa=a+gold^(best+1)*da;
		if (any(newa<0)|(newa(2)+newa(3)>1-eps))
			right=-Inf;
		else
			h=filter([0 newa(2)],[1 -newa(3)],y*(df-2)/df,s*(df-2)/df)...
		   	  +filter([0 newa(1)],[1 -newa(3)],ones(t,1));
        %right=-sum(log(h)+y./h);
         right=-sum(log(h)+(df+1)*log(1+y./h./df));
		end
		if center>right
			break
		end
	end
end

% If stuck at boundary then stop
if (center==like)&(any(a<tol2)|(a(2)+a(3)>1-tol2))
	break
end

% End of optimization loop
end
a(a<tol2)=zeros(size(a(a<tol2)));
if a(2)+a(3)>1-tol2
	if a(2)<1-tol2
		a(2)=a(2)+(1-a(2)-a(3));
	else
		a(3)=a(3)+(1-a(2)-a(3));
	end
end

% Estimation error and volatility forecast
% invhes=inv(reshape(sum(H),3,3));
aerr=inv(G'*G);
hf=a(1)+a(2)*y(t)*(df-2)/df+a(3)*h(t);
gf=[1 y(t) h(t)]+a(3)*GG(t,:);
hferr=gf*aerr*gf';
aerr=diag(aerr)';

% Revert to original scale
a(1)=a(1)*scale;
aerr(1)=aerr(1)*scale^2;
hf=hf*scale;
hferr=hferr*scale^2;

aerr=sqrt(aerr);
hferr=sqrt(hferr);
q=a;
qerr=aerr;
